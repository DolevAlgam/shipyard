# Task ID: 33
# Title: Implement Complete Conversation Archive Transmission to DocumentGeneratorAgent
# Status: pending
# Dependencies: 2, 5, 7, 11, 12, 16
# Priority: high
# Description: Ensure DocumentGeneratorAgent receives the complete conversation archive including all questions asked, answers given, follow-up exchanges, and skipped items with reasons, enabling the final document to reflect the full scope of discussions and considerations that arose during the interview process.
# Details:
**COMPREHENSIVE CONVERSATION ARCHIVE IMPLEMENTATION**

**1. Create Conversation Archive Structure** (`core/conversation_archive.py`):
```python
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

class ConversationItemType(str, Enum):
    QUESTION = "question"
    ANSWER = "answer"
    FOLLOW_UP = "follow_up"
    SKIPPED = "skipped"
    CLARIFICATION = "clarification"
    AI_RECOMMENDATION = "ai_recommendation"
    USER_OVERRIDE = "user_override"

@dataclass
class ConversationItem:
    timestamp: datetime
    agent: str
    topic: str
    item_type: ConversationItemType
    content: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    
@dataclass
class SkippedItem:
    timestamp: datetime
    agent: str
    topic: str
    question: str
    skip_reason: str
    potential_impact: Optional[str] = None

class ConversationArchive:
    def __init__(self):
        self.conversations: List[ConversationItem] = []
        self.skipped_items: List[SkippedItem] = []
        self.follow_up_chains: Dict[str, List[ConversationItem]] = {}
        
    def add_conversation(self, agent: str, topic: str, item_type: ConversationItemType, 
                        content: str, metadata: Optional[Dict] = None):
        item = ConversationItem(
            timestamp=datetime.now(),
            agent=agent,
            topic=topic,
            item_type=item_type,
            content=content,
            metadata=metadata or {}
        )
        self.conversations.append(item)
        
    def add_skipped_item(self, agent: str, topic: str, question: str, 
                        skip_reason: str, potential_impact: Optional[str] = None):
        skipped = SkippedItem(
            timestamp=datetime.now(),
            agent=agent,
            topic=topic,
            question=question,
            skip_reason=skip_reason,
            potential_impact=potential_impact
        )
        self.skipped_items.append(skipped)
        
    def add_follow_up_chain(self, topic_key: str, conversation_items: List[ConversationItem]):
        self.follow_up_chains[topic_key] = conversation_items
        
    def get_complete_archive(self) -> Dict[str, Any]:
        return {
            "conversations": [self._serialize_item(item) for item in self.conversations],
            "skipped_items": [self._serialize_skipped(item) for item in self.skipped_items],
            "follow_up_chains": {
                key: [self._serialize_item(item) for item in chain]
                for key, chain in self.follow_up_chains.items()
            },
            "statistics": self._generate_statistics()
        }
```

**2. Update StateManager to Include Archive** (`core/state_manager.py`):
```python
# Add to existing StateManager
from .conversation_archive import ConversationArchive

class StateManager:
    def __init__(self):
        # Existing initialization...
        self.conversation_archive = ConversationArchive()
        
    def record_question(self, agent: str, topic: str, question: str, metadata: Optional[Dict] = None):
        self.conversation_archive.add_conversation(
            agent=agent,
            topic=topic,
            item_type=ConversationItemType.QUESTION,
            content=question,
            metadata=metadata
        )
        
    def record_answer(self, agent: str, topic: str, answer: str, metadata: Optional[Dict] = None):
        self.conversation_archive.add_conversation(
            agent=agent,
            topic=topic,
            item_type=ConversationItemType.ANSWER,
            content=answer,
            metadata=metadata
        )
        
    def record_skipped(self, agent: str, topic: str, question: str, reason: str, impact: Optional[str] = None):
        self.conversation_archive.add_skipped_item(
            agent=agent,
            topic=topic,
            question=question,
            skip_reason=reason,
            potential_impact=impact
        )
        
    def get_complete_conversation_archive(self) -> Dict[str, Any]:
        return self.conversation_archive.get_complete_archive()
```

**3. Update All Agents to Record Conversations** (`agents/base_agent.py`):
```python
# Modify process_topic method to record all interactions
async def process_topic(self, topic: str, state: Dict, openai_client, state_manager: StateManager) -> Dict:
    # Get question from agent
    question = await self._generate_question(topic, state, openai_client)
    
    # Record the question
    state_manager.record_question(
        agent=self.name,
        topic=topic,
        question=question,
        metadata={"expertise_level": state.get("user_profile", {}).get("expertise_level")}
    )
    
    # Get user answer
    user_answer = await self._get_user_input(question)
    
    # Check if user skipped
    if self._is_skip_response(user_answer):
        skip_reason = self._extract_skip_reason(user_answer)
        potential_impact = await self._assess_skip_impact(topic, openai_client)
        
        state_manager.record_skipped(
            agent=self.name,
            topic=topic,
            question=question,
            reason=skip_reason,
            impact=potential_impact
        )
        return {"skipped": True, "reason": skip_reason}
    
    # Record the answer
    state_manager.record_answer(
        agent=self.name,
        topic=topic,
        answer=user_answer,
        metadata={"word_count": len(user_answer.split())}
    )
    
    # Handle follow-ups if needed
    if self.needs_follow_up(user_answer):
        follow_up_chain = await self._handle_follow_up_chain(topic, user_answer, state, openai_client, state_manager)
        state_manager.conversation_archive.add_follow_up_chain(f"{self.name}_{topic}", follow_up_chain)
```

**4. Update DocumentGeneratorAgent to Use Complete Archive** (`agents/document_generator.py`):
```python
class DocumentGeneratorAgent:
    async def generate_document(self, state: Dict, openai_client, state_manager: StateManager) -> str:
        # Get complete conversation archive
        complete_archive = state_manager.get_complete_conversation_archive()
        
        # Create enhanced prompt with full context
        enhanced_prompt = self._create_enhanced_prompt(complete_archive)
        
        # Generate document with full conversation awareness
        document_prompt = f"""
        Generate a comprehensive infrastructure document based on the COMPLETE conversation history.
        
        IMPORTANT: Include considerations for ALL topics discussed, including:
        1. All answered questions and the specific responses
        2. Topics the user skipped and why (mark these as "User opted to skip")
        3. Follow-up clarifications and their resolutions
        4. Any AI recommendations that were accepted or rejected
        
        Full Conversation Archive:
        {json.dumps(complete_archive, indent=2)}
        
        The document should reflect the full scope of the interview, acknowledging both:
        - What the user explicitly chose to implement
        - What they consciously decided to skip (with notes about potential future considerations)
        
        This ensures the infrastructure plan is comprehensive and accounts for all considerations
        that came up during the interview process.
        """
        
        response = await openai_client.call_agent(
            system_prompt=DOCUMENT_GENERATOR_PROMPT,
            user_message=document_prompt,
            chat_history=self._prepare_full_history(complete_archive)
        )
        
        return response
        
    def _prepare_full_history(self, archive: Dict) -> List[Dict]:
        """Convert archive to OpenAI message format preserving full context"""
        messages = []
        
        # Include all conversations
        for conv in archive["conversations"]:
            role = "assistant" if conv["item_type"] == "question" else "user"
            messages.append({
                "role": role,
                "content": f"[{conv['agent']} - {conv['topic']}] {conv['content']}"
            })
            
        # Include skipped items as system notes
        for skipped in archive["skipped_items"]:
            messages.append({
                "role": "system",
                "content": f"Note: User skipped {skipped['topic']} - Reason: {skipped['skip_reason']}"
            })
            
        return messages
```

**5. Create Archive Serialization Methods**:
```python
# In ConversationArchive class
def _serialize_item(self, item: ConversationItem) -> Dict:
    return {
        "timestamp": item.timestamp.isoformat(),
        "agent": item.agent,
        "topic": item.topic,
        "type": item.item_type,
        "content": item.content,
        "metadata": item.metadata
    }
    
def _serialize_skipped(self, item: SkippedItem) -> Dict:
    return {
        "timestamp": item.timestamp.isoformat(),
        "agent": item.agent,
        "topic": item.topic,
        "question": item.question,
        "skip_reason": item.skip_reason,
        "potential_impact": item.potential_impact
    }
    
def _generate_statistics(self) -> Dict:
    return {
        "total_questions": len([c for c in self.conversations if c.item_type == ConversationItemType.QUESTION]),
        "total_answers": len([c for c in self.conversations if c.item_type == ConversationItemType.ANSWER]),
        "skipped_topics": len(self.skipped_items),
        "follow_up_chains": len(self.follow_up_chains),
        "agents_involved": list(set(c.agent for c in self.conversations))
    }
```

**6. Update Main Orchestration Loop** (`main.py`):
```python
# Pass state_manager to all agent calls
async def run_interview():
    state_manager = StateManager()
    # ... existing code ...
    
    # Update all agent process calls
    for topic in agent.topics:
        result = await agent.process_topic(topic, state, openai_client, state_manager)
        
    # When generating document
    document = await document_generator.generate_document(state, openai_client, state_manager)
```

# Test Strategy:
**COMPREHENSIVE TESTING FOR CONVERSATION ARCHIVE SYSTEM**:

**1. Archive Recording Verification**:
- Test that every question asked by agents is recorded with correct timestamp, agent name, and topic
- Verify all user answers are captured with proper metadata (word count, response time if tracked)
- Confirm skipped items are recorded with skip reasons and potential impact assessments
- Test follow-up conversation chains are properly grouped and linked to original topics

**2. Data Completeness Testing**:
- Create test scenario where user answers 5 questions, skips 2, and has 3 follow-up exchanges
- Verify archive contains exactly 5 questions, 5 answers, 2 skipped items, and 3 follow-up chains
- Test that no conversations are lost during agent transitions
- Verify archive statistics accurately reflect all recorded items

**3. DocumentGeneratorAgent Integration Testing**:
- Mock a complete interview with various interaction types (answers, skips, follow-ups)
- Verify DocumentGeneratorAgent receives the complete archive in its prompt
- Test that generated document mentions skipped topics with "User opted to skip" notation
- Confirm document includes considerations from follow-up clarifications

**4. Serialization and Format Testing**:
- Test JSON serialization of all conversation types produces valid, parseable output
- Verify timestamps are properly formatted (ISO format)
- Test that metadata fields are preserved through serialization
- Confirm archive can be reconstructed from serialized format

**5. Edge Case Testing**:
- Test with empty conversations (user skips everything)
- Test with extensive follow-up chains (5+ follow-ups on single topic)
- Verify system handles missing metadata gracefully
- Test with special characters in user responses

**6. Performance Testing**:
- Test with large conversation archives (100+ interactions)
- Verify archive retrieval remains performant
- Test memory usage with extensive conversation histories

**7. Integration with Existing Systems**:
- Verify archive doesn't interfere with existing state management
- Test that summaries still work correctly alongside full archive
- Confirm agent context sharing (Task #11) still functions with archive system
